import prisma from "../utils/prisma.js";
import { success } from "../utils/response.js";
import ghnService from "../services/ghn.service.js";

export const getUsers = async (req, res, next) => {
	try {
		const users = await prisma.user.findMany({
			select: {
				id: true,
				name: true,
				email: true,
				phone: true,
				address: true,
				city: true,
				role: true,
				isActive: true,
				createdAt: true,
			},
		});
		success(res, users);
	} catch (err) {
		next(err);
	}
};

export const updateProfile = async (req, res, next) => {
	try {
		console.log('=== updateProfile REQUEST RECEIVED ===');
		console.log('Method:', req.method);
		console.log('URL:', req.url);
		console.log('Headers:', JSON.stringify(req.headers, null, 2));
		console.log('Body:', JSON.stringify(req.body, null, 2));
		
		const userId = req.user.id;
        let { name, phone, address, city, birthDate, gender } = req.body;
        
        // Sanitize strings: remove null bytes and trim whitespace
        const sanitizeString = (str) => {
			if (str === null || str === undefined) return null;
			if (typeof str !== 'string') {
				// If it's not a string, try to convert it
				if (str && typeof str.toString === 'function') {
					str = str.toString();
				} else {
					return str;
				}
			}
			// Remove null bytes (0x00) and other control characters that might cause issues
			// Also trim whitespace
			let cleaned = str.replace(/\0/g, '').replace(/[\x00-\x1F\x7F]/g, '').trim();
			return cleaned || null;
		};
		
		name = name !== undefined ? sanitizeString(name) : undefined;
		phone = phone !== undefined ? sanitizeString(phone) : undefined;
		address = address !== undefined ? sanitizeString(address) : undefined;
		city = city !== undefined ? sanitizeString(city) : undefined;
		gender = gender !== undefined ? sanitizeString(gender) : undefined;
        
        console.log('updateProfile - received data:', {
			userId,
			name,
			phone,
			address,
			city,
			birthDate,
			gender,
			birthDateType: typeof birthDate,
			genderType: typeof gender
		});
        
		const existingUser = await prisma.user.findUnique({ where: { id: userId } });
		if (!existingUser) {
			return res.status(404).json({ error: "User not found" });
		}
		
		// Prepare update data - ensure all string values are sanitized
		const updateData = {};
		if (name !== undefined) {
			updateData.name = name; // Already sanitized above
		}
		if (phone !== undefined) {
			updateData.phone = phone; // Already sanitized above
		}
		if (address !== undefined) {
			updateData.address = address; // Already sanitized above
		}
		if (city !== undefined) {
			updateData.city = city; // Already sanitized above
		}
		
		// Also sanitize existing data if we're not updating those fields
		// This prevents null bytes from existing data from causing issues
		if (updateData.name === undefined && existingUser.name) {
			const cleanedName = sanitizeString(existingUser.name);
			if (cleanedName !== existingUser.name) {
				updateData.name = cleanedName;
			}
		}
		if (updateData.phone === undefined && existingUser.phone) {
			const cleanedPhone = sanitizeString(existingUser.phone);
			if (cleanedPhone !== existingUser.phone) {
				updateData.phone = cleanedPhone;
			}
		}
		
		// Always process birthDate if it's in the request
		if (birthDate !== undefined) {
			// Handle birthDate: convert string to DateTime or set to null
			if (birthDate === null || birthDate === "" || (typeof birthDate === 'string' && birthDate.trim() === "")) {
				updateData.birthDate = null;
			} else {
				try {
					// Sanitize birthDate string if it's a string
					let dateStr = birthDate;
					if (typeof dateStr === 'string') {
						dateStr = dateStr.replace(/\0/g, '').trim();
					}
					const dateValue = new Date(dateStr);
					// Validate date
					if (isNaN(dateValue.getTime())) {
						return res.status(400).json({ error: "Invalid birthDate format" });
					}
					updateData.birthDate = dateValue;
				} catch (dateError) {
					return res.status(400).json({ error: "Invalid birthDate format", details: dateError.message });
				}
			}
		}
		
		// Always process gender if it's in the request
		if (gender !== undefined) {
			// Validate gender value
			if (gender !== null && gender !== "" && !['Nam', 'Nữ', 'Khác'].includes(gender)) {
				return res.status(400).json({ error: "Invalid gender value. Must be 'Nam', 'Nữ', or 'Khác'" });
			}
			updateData.gender = (gender === "" || gender === null) ? null : gender;
		}
		
		console.log('updateProfile - updateData to save:', updateData);
		console.log('updateProfile - updateData keys:', Object.keys(updateData));
		console.log('updateProfile - updateData values:', Object.values(updateData));
		
		// Final sanitization: ensure no null bytes in any string field
		// Also validate Date objects
		for (const key in updateData) {
			if (updateData[key] === null || updateData[key] === undefined) {
				continue; // Skip null/undefined values
			}
			
			if (updateData[key] instanceof Date) {
				// For Date objects, ensure they're valid
				if (isNaN(updateData[key].getTime())) {
					console.error(`Invalid date for ${key}:`, updateData[key]);
					delete updateData[key];
					continue;
				}
				// Date objects should be fine, but log for debugging
				console.log(`${key} is a valid Date:`, updateData[key].toISOString());
			} else if (typeof updateData[key] === 'string') {
				const original = updateData[key];
				updateData[key] = sanitizeString(updateData[key]);
				if (original !== updateData[key]) {
					console.log(`Sanitized ${key}: "${original}" -> "${updateData[key]}"`);
				}
				// Double check for null bytes after sanitization
				if (updateData[key] && updateData[key].includes('\0')) {
					console.error(`WARNING: ${key} still contains null bytes after sanitization!`);
					updateData[key] = updateData[key].replace(/\0/g, '');
				}
			}
		}
		
		console.log('updateProfile - final updateData after sanitization:', updateData);
		console.log('updateProfile - final updateData JSON:', JSON.stringify(updateData));
		
		// Only include fields that exist in updateData to avoid Prisma errors
		const user = await prisma.user.update({
			where: { id: userId },
			data: updateData,
			select: {
				id: true,
				name: true,
				email: true,
				phone: true,
				address: true,
				city: true,
				birthDate: true,
				gender: true,
				role: true,
				isActive: true,
				createdAt: true,
				updatedAt: true,
			},
		});
		// Log for debugging
		console.log('updateProfile - updated user data:', {
			id: user.id,
			name: user.name,
			email: user.email,
			phone: user.phone,
			birthDate: user.birthDate,
			gender: user.gender,
			birthDateType: typeof user.birthDate,
			genderType: typeof user.gender,
			updateData: updateData
		});
		// Disable caching for profile endpoint
		res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
		res.setHeader('Pragma', 'no-cache');
		res.setHeader('Expires', '0');
		success(res, user);
	} catch (err) {
		console.error("Error updating profile:", err);
		// Log more details about the error
		if (err.code) {
			console.error("Prisma error code:", err.code);
		}
		if (err.meta) {
			console.error("Prisma error meta:", err.meta);
		}
		// If it's a Prisma error about unknown field, provide helpful message
		if (err.message && err.message.includes("Unknown argument") || err.message.includes("Unknown field")) {
			return res.status(500).json({ 
				error: "Database schema mismatch", 
				message: "The database may not have the birthDate or gender columns. Please run migrations.",
				details: err.message 
			});
		}
		next(err);
	}
};

export const getProfile = async (req, res, next) => {
	try {
		const userId = req.user.id;
		const user = await prisma.user.findUnique({
			where: { id: userId },
			select: {
				id: true,
				name: true,
				email: true,
				phone: true,
				address: true,
				city: true,
				birthDate: true,
				gender: true,
				role: true,
				isActive: true,
				createdAt: true,
				updatedAt: true,
				orders: {
					select: {
						id: true,
						totalPrice: true,
						status: true,
						createdAt: true,
						ghnOrderCode: true,
						orderItems: {
							select: {
								quantity: true,
								product: { select: { id: true, name: true, image: true, price: true } },
							},
						},
					},
					orderBy: { createdAt: "desc" },
					take: 10,
				},
			},
		});
		if (!user) {
			return res.status(404).json({ error: "User not found" });
		}
		// Log for debugging - log all fields
		console.log('getProfile - user data:', {
			id: user.id,
			name: user.name,
			email: user.email,
			phone: user.phone,
			address: user.address,
			city: user.city,
			birthDate: user.birthDate,
			gender: user.gender,
			birthDateType: typeof user.birthDate,
			genderType: typeof user.gender
		});
		console.log('getProfile - full user object:', JSON.stringify(user, null, 2));
		// Disable caching for profile endpoint to ensure fresh data
		res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
		res.setHeader('Pragma', 'no-cache');
		res.setHeader('Expires', '0');
		success(res, user);
	} catch (err) {
		console.error('getProfile error:', err);
		next(err);
	}
};

export const cancelUserOrder = async (req, res, next) => {
	try {
		const userId = req.user.id;
		const { orderId } = req.params;
		const order = await prisma.order.findFirst({
			where: { id: orderId, userId },
			select: { id: true, status: true, ghnOrderCode: true, createdAt: true, user: { select: { id: true, name: true, email: true } } },
		});
		if (!order) {
			return res.status(404).json({ error: "Đơn hàng không tồn tại hoặc không thuộc về bạn" });
		}
		if (order.status === "CANCELLED") {
			return res.status(400).json({ error: "Đơn hàng đã được hủy trước đó" });
		}
		if (order.status === "COMPLETED") {
			return res.status(400).json({ error: "Không thể hủy đơn hàng đã hoàn thành" });
		}
		if (order.status === "SHIPPING") {
			return res.status(400).json({ error: "Không thể hủy đơn hàng đang vận chuyển" });
		}
		const orderAge = Date.now() - new Date(order.createdAt).getTime();
		const maxCancelTime = 24 * 60 * 60 * 1000;
		if (orderAge > maxCancelTime) {
			return res.status(400).json({ error: "Chỉ có thể hủy đơn hàng trong vòng 24 giờ đầu" });
		}
		let ghnResult = null;
		if (order.ghnOrderCode) {
			try {
				ghnResult = await ghnService.cancelOrder(order.ghnOrderCode);
			} catch (ghnError) {
				ghnResult = { success: false, error: ghnError.message, message: "Lỗi khi hủy đơn hàng trên GHN" };
			}
		}
		const updatedOrder = await prisma.order.update({
			where: { id: orderId },
			data: { status: "CANCELLED", updatedAt: new Date() },
			include: {
				user: { select: { id: true, name: true, email: true, phone: true } },
				orderItems: { include: { product: { select: { id: true, name: true, image: true, price: true } } } },
			},
		});
		success(res, { success: true, message: "Đơn hàng đã được hủy thành công", order: updatedOrder, ghnResult });
	} catch (err) {
		next(err);
	}
};
